// Code generated by github.com/fjl/gencodec. DO NOT EDIT.

package types

import (
	"encoding/json"
	"math/big"
)

var _ = (*orderStateMarshaling)(nil)

func (o OrderState) MarshalJSON() ([]byte, error) {
	type OrderState struct {
		RawOrder        Order       `json:"rawOrder"`
		Owner           Address     `json:"owner" `
		OrderHash       Hash        `json:"orderHash"`
		RemainedAmountS *Big        `json:"remainedAmountS"`
		RemainedAmountB *Big        `json:"remainedAmountB"`
		Status          OrderStatus `json:"status"`
	}
	var enc OrderState
	enc.RawOrder = o.RawOrder
	enc.Owner = o.Owner
	enc.OrderHash = o.OrderHash
	enc.RemainedAmountS = (*Big)(o.RemainedAmountS)
	enc.RemainedAmountB = (*Big)(o.RemainedAmountB)
	enc.Status = o.Status
	return json.Marshal(&enc)
}

func (o *OrderState) UnmarshalJSON(input []byte) error {
	type OrderState struct {
		RawOrder        *Order       `json:"rawOrder"`
		Owner           *Address     `json:"owner" `
		OrderHash       *Hash        `json:"orderHash"`
		RemainedAmountS *Big         `json:"remainedAmountS"`
		RemainedAmountB *Big         `json:"remainedAmountB"`
		Status          *OrderStatus `json:"status"`
	}
	var dec OrderState
	if err := json.Unmarshal(input, &dec); err != nil {
		return err
	}
	if dec.RawOrder != nil {
		o.RawOrder = *dec.RawOrder
	}
	if dec.Owner != nil {
		o.Owner = *dec.Owner
	}
	if dec.OrderHash != nil {
		o.OrderHash = *dec.OrderHash
	}
	if dec.RemainedAmountS != nil {
		o.RemainedAmountS = (*big.Int)(dec.RemainedAmountS)
	}
	if dec.RemainedAmountB != nil {
		o.RemainedAmountB = (*big.Int)(dec.RemainedAmountB)
	}
	if dec.Status != nil {
		o.Status = *dec.Status
	}
	return nil
}
